<?php

/**
 * @file
 * Turn Drupal to a RESTful server, following best practices.
 */

/**
 * Implements hook_ctools_plugin_directory().
 */
function restful_ctools_plugin_directory($module, $plugin) {
  if ($module == 'restful') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Add defaults values to the restful related plugins.
 *
 * Properties for the "restful" plugin type:
 * - description: The description of the resource. Defaults to empty string.
 * - major_version: The major version of the resource. This will change the URL
 *   of the resource endpoint. For example setting major version to 2 for the
 *   "articles" resource will result with "api/v2/articles" as the URL. Defaults
 *   to 1.
 * - minor_version: The minor version of the resource. Setting the minor version
 *   via CURL is done by setting HTTP_RESTFUL_MINOR_VERSION in the HTTP headers.
 *   Defaults to 0.
 * - options: Array of options needed for the plugin. See
 *   "per_role_content__1_0.inc" in RESTful example module. Defaults to empty
 *   array.
 * - entity type: The entity type of the resource. Defaults to FALSE, which
 *   indicates the resource isn't connected to any entity type.
 * - bundle: The name of a single bundle the resource is connected to. Defaults
 *   to FALSE.
 * - authentication_types: Array with name of authentication providers that
 *   should "protect" the resource, and ensure only authenticated users can use
 *   it. If
 *   user was not authenticated with any of the authentication providers, an
 *   \RestfulUnauthorizedException exception would be thrown. Defaults to empty
 *   array, which means no authentication is done by default.
 * - hook_menu: Determines if RESTful module should declare the resource in its
 *   pwn hook_menu(). If FALSE, it is up to the implementing module to declare
 *   it. Defaults to TRUE.
 * - cache_render: Set it to FALSE to disable the render cache completely
 *   Defaults to FALSE.
 * - cache_class: The cache class for this resource. Defaults to NULL, which
 *   will probably end up resolving to 'DrupalDatabaseCache'.
 * - cache_bin: The name of the bin. It is the developer's responsibility to
 *   create this bin in the cache backend if it does not exist. Defaults to
 *   'cache_restful'.
 * - cache_expire: TTL for the cache records. See DrupalCacheInterface::set()
 *   for the allowed values. Defaults to CACHE_PERMANENT.
 * - cache_simple_invalidate: Set it to false to prevent the RESTful module to
 *   invalidate any cache it may have been generated. The developer will be
 *   responsible to invalidate caches in this scenario. Defaults to TRUE.
 *
 * Properties for the "authentication" plugin type:
 * - description: The description of the authentication provider. Defaults to
 *   empty string.
 * - settings: Array with the settings needed for the plugin. Defaults to empty
 *   array.
 */
function restful_plugin_process(&$plugin, $info) {
  if ($info['type'] == 'restful') {
    $plugin += array(
      'description' => '',
      'major_version' => 1,
      'minor_version' => 0,
      'options' => array(),
      'entity_type' => FALSE,
      'bundle' => FALSE,
      'authentication_types' => array(),
      'hook_menu' => TRUE,
      'cache_render' => FALSE,
      'cache_class' => NULL,
      'cache_bin' => 'cache_restful',
      'cache_expire' => CACHE_PERMANENT,
      'cache_simple_invalidate' => TRUE,
    );

    if ($plugin['hook_menu'] && empty($plugin['menu_item'])) {
      // Set a default menu item.
      $base_path = variable_get('restful_hook_menu_base_path', 'api/%');
      $base_path = str_replace('%', 'v' . $plugin['major_version'], $base_path);
      $plugin['menu_item'] = $base_path . '/' . $plugin['resource'];
    }
  }
  elseif ($info['type'] == 'authentication') {
    $plugin += array(
      'description' => '',
      'settings' => array(),
    );
  }
}

/**
 * Implements hook_ctools_plugin_type().
 */
function restful_ctools_plugin_type() {
  $plugins['authentication'] = $plugins['restful'] = array(
    'classes' => array('class'),
    'process' => 'restful_plugin_process',
  );
  $plugins['restful']['child plugins'] = TRUE;
  return $plugins;
}


/**
 * Include CTools plugins and get all restful plugins.
 *
 * @return array
 *   All plugins for restful resources.
 */
function restful_get_restful_plugins() {
  ctools_include('plugins');
  return ctools_get_plugins('restful', 'restful');
}

/**
 * Include CTools plugins and get all authentication plugins.
 *
 * @return array
 *   All plugins for restful authentication.
 */
function restful_get_authentication_plugins() {
  ctools_include('plugins');
  return ctools_get_plugins('restful', 'authentication');
}

/**
 * Include CTools plugins and get the specified authentication plugin.
 *
 * @param string $plugin_name
 *   If provided this function only returns the selected plugin.
 *
 * @return array
 *   The selected plugin for restful authentication.
 */
function restful_get_authentication_plugin($plugin_name) {
  ctools_include('plugins');
  return ctools_get_plugins('restful', 'authentication', $plugin_name);
}

/**
 * Implements hook_menu().
 */
function restful_menu() {
  $items = array();
  foreach (restful_get_restful_plugins() as $plugin) {
    if (!$plugin['hook_menu']) {
      // Plugin explicitly declared no hook menu should be created automatically
      // for it.
      continue;
    }

    $items[$plugin['menu_item']] = array(
      'title' => $plugin['name'],
      'access callback' => 'restful_menu_access_callback',
      'access arguments' => array(1, 2),
      'page callback' => 'restful_menu_process_callback',
      'page arguments' => array(1, 2),
      'delivery callback' => 'restful_json_output',
    );
  }

  // A special login endpoint, that returns a JSON output along with the Drupal
  // authentication cookie.
  if (variable_get('restful_user_login_menu_item', TRUE)) {
    $items['api/login'] = array(
      'title' => 'Login',
      'description' => 'Login using base auth and recieve a JSON response along with an authentication cookie.',
      'access callback' => 'user_is_anonymous',
      'page callback' => 'restful_menu_process_callback',
      'page arguments' => array('1', 'login_cookie'),
      'delivery callback' => 'restful_json_output',
    );
  }

  return $items;
}


/**
 * Return the handler based on major and minor version, and resource name.
 *
 * @param $resource_name
 *   The name of the resource (e.g. "articles").
 * @param int $major_version
 *   (optional) The major version (not prefixed with "v"). Defaults to 1.
 * @param int $minor_version
 *   (optional) The minor version. Defaults to 0.
 *
 * @return RestfulInterface | NULL
 *   The handler object if found, or NULL.
 */
function restful_get_restful_handler($resource_name, $major_version = 1, $minor_version = 0) {
  $cache = &drupal_static(__FUNCTION__);
  $identifier = implode(':', array($major_version, $resource_name, $minor_version));
  if (isset($cache[$identifier])) {
    return $cache[$identifier];
  }

  $cache[$identifier] = NULL;


  // Array with all the handlers with the same major version and resource name.
  // We get all of them, so we can find the correct one if minor version is
  // present.
  $valid_plugins = array();
  foreach (restful_get_restful_plugins() as $plugin) {
    if ($plugin['major_version'] != $major_version) {
      continue;
    }

    if ($plugin['resource'] != $resource_name) {
      continue;
    }

    if ($minor_version == $plugin['minor_version']) {
      // We found out handler, so we can break.
      $valid_plugins[$plugin['minor_version']] = $plugin;
      break;
    }

    if ($plugin['minor_version'] > $minor_version) {
      // Minor version is above the needed one.
      continue;
    }

    $valid_plugins[$plugin['minor_version']] = $plugin;
  }

  if (!$valid_plugins) {
    return;
  }

  // Sort the handlers, and get the last one, as it is the closest one to the
  // requested minor version.
  ksort($valid_plugins);
  $plugin = end($valid_plugins);

  $cache[$identifier] = restful_get_restful_handler_by_name($plugin['name']);

  return $cache[$identifier];
}

/**
 * Return the handler based on major and minor version, and resource name.
 *
 * @param $plugin_name
 *   The name of the plugin, including version. (e.g. "articles__1_2").
 *
 * @return RestfulInterface | NULL
 *   The handler object if found, or NULL.
 */
function restful_get_restful_handler_by_name($plugin_name) {
  ctools_include('plugins');
  $plugin = ctools_get_plugins('restful', 'restful', $plugin_name);
  $class = ctools_plugin_load_class('restful', 'restful', $plugin_name, 'class');
  $handler = new $class($plugin);
  // If the restful plugin needs authentication load the corresponding
  // authentication plugin.

  // We can have multiple authentication plugins.
  foreach ($plugin['authentication_types'] as $auth_plugin_name) {
    $auth_handler = restful_get_authentication_handler($auth_plugin_name);
    $handler->getAuthenticationManager()->addAuthenticationProvider($auth_handler);
  }
  return $handler;
}
/**
 * Return the authentication handler based on the authentication plugin name.
 *
 * @param string $auth_plugin_name
 *   Name of the authentication plugin.
 *
 * @return \RestfulAuthenticationInterface
 *   The authentication provider object.
 *
 * @throws \RestfulException if the authentication provider does not exist.
 */
function restful_get_authentication_handler($auth_plugin_name) {
  $auth_plugin = restful_get_authentication_plugin($auth_plugin_name);
  $auth_class = ctools_plugin_get_class($auth_plugin, 'class');
  return new $auth_class($auth_plugin);
}

/**
 * Access callback; Determine access for an API call.
 *
 * @param $major_version
 *   The major version, prefixed with v (e.g. v1, v2).
 * @param $resource_name
 *   The name of the resource (e.g. "articles").
 *
 * @return bool
 *   TRUE if user is allowed to access resource.
 */
function restful_menu_access_callback($major_version, $resource_name) {
  if ($major_version[0] != 'v') {
    // Major version not prefixed with "v".
    return;
  }

  if (!$major_version = intval(str_replace('v', '', $major_version))) {
    // Major version is not an integer.
    return;
  }

  $minor_version = !empty($_SERVER['HTTP_RESTFUL_MINOR_VERSION']) && is_int($_SERVER['HTTP_RESTFUL_MINOR_VERSION']) ? $_SERVER['HTTP_RESTFUL_MINOR_VERSION'] : 0;
  if (!$handler = restful_get_restful_handler($resource_name, $major_version, $minor_version)) {
    return;
  }

  if (!in_array($_SERVER['REQUEST_METHOD'], array('GET', 'POST', 'PUT', 'PATCH', 'DELETE'))) {
    return;
  }

  return $handler->access();
}

/**
 * Page callback; Return the response for an API call.
 *
 * @param $major_version
 *   The major version, prefixed with v (e.g. v1, v2).
 * @param $resource_name
 *   The name of the resource (e.g. "articles").
 *
 * @return string
 *   JSON output with the result of the API call.
 *
 * @see http://tools.ietf.org/html/draft-nottingham-http-problem-06
 */
function restful_menu_process_callback($major_version, $resource_name) {
  $major_version = intval(str_replace('v', '', $major_version));
  $minor_version = !empty($_SERVER['HTTP_RESTFUL_MINOR_VERSION']) && is_numeric($_SERVER['HTTP_RESTFUL_MINOR_VERSION']) ? $_SERVER['HTTP_RESTFUL_MINOR_VERSION'] : 0;
  $handler = restful_get_restful_handler($resource_name, $major_version, $minor_version);

  $path = func_get_args();
  unset($path[0], $path[1]);
  $path = implode('/', $path);

  $request = NULL;
  $method = strtolower($_SERVER['REQUEST_METHOD']);

  switch ($method) {
    case 'get':
      $request = $_GET;
      break;

    case 'post':
      $request = $_POST;
      break;

    default:
      if ($query_string = file_get_contents('php://input')) {
        parse_str($query_string, $request);
      }
      break;
  }
  // This flag is used to identify if the request is done "via Drupal" or "via
  // CURL";
  $request['application'] = array('rest_call' => TRUE);

  try {
    $result = $handler->{$method}($path, $request);
    // Allow the handler to change the HTTP headers.
    foreach ($handler->getHttpHeaders() as $key => $value) {
      drupal_add_http_header($key, $value);
    }

    drupal_add_http_header('Content-Type', 'application/hal+json; charset=utf-8');
    return $result;
  }
  catch (RestfulException $e) {
    $result = array(
      'type' => $e->getType(),
      'title' => $e->getMessage(),
      'status' => $e->getCode(),
      'detail' => $e->getDescription(),
      'instance' => $e->getInstance(),
    );
  }
  catch (Exception $e) {
    $result = array(
      'type' => 'http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.1',
      'title' => $e->getMessage(),
      'status' => 500,
    );
  }

  // Adhere to the API Problem draft proposal.
  drupal_add_http_header('Status', $result['status']);
  drupal_add_http_header('Content-Type', 'application/problem+json; charset=utf-8');
  return $result;
}

/**
 * Returns data in JSON format.
 *
 * We do not use drupal_json_output(), in order to maintain the "Content-Type"
 * header.
 *
 * @param $var
 *   (optional) If set, the variable will be converted to JSON and output.
 *
 * @see restful_menu_process_callback()
 */
function restful_json_output($var = NULL) {
  if (isset($var)) {
    echo drupal_json_encode($var);
  }
}


/**
 * Implements hook_entity_update().
 */
function restful_entity_update($entity, $type) {
  list($entity_id) = entity_extract_ids($type, $entity);
  $cid = 'et' . $type . '::ei' . $entity_id . '::uu';
  _restful_invalidate_entity_cache($cid);
}

/**
 * Implements hook_entity_delete().
 */
function restful_entity_delete($entity, $type) {
  list($entity_id) = entity_extract_ids($type, $entity);
  $cid = 'et' . $type . '::ei' . $entity_id . '::uu';
  _restful_invalidate_entity_cache($cid);
}

/**
 * Implements hook_user_update().
 */
function restful_user_update(&$edit, $account, $category) {
  // Due to the limitations for cid matching on clearing caches, we need to
  // clear all the bin. We cannot do $cid = '%::uu' . $account->uid . '::pa';
  _restful_invalidate_entity_cache('*');
}

/**
 * Implements hook_user_delete().
 */
function restful_user_delete($account) {
  // Due to the limitations for cid matching on clearing caches, we need to
  // clear all the bin. We cannot do $cid = '%::uu' . $account->uid . '::pa';
  _restful_invalidate_entity_cache('*');
}

/**
 * Delete cached entities from all the cache bins associated to restful
 * resources.
 *
 * @param string $cid
 *   The wildcard cache id to invalidate.
 */
function _restful_invalidate_entity_cache($cid) {
  $plugins = restful_get_restful_plugins();
  foreach ($plugins as $plugin) {
    $handler = restful_get_restful_handler($plugin['resource'], $plugin['major_version'], $plugin['minor_version']);
    $reflector = new \ReflectionClass($handler);
    if ($reflector->hasMethod('cacheInvalidate')) {
      $version = $handler->getVersion();
      $version_cid = 'v' . $version['major'] . '.' . $version['minor'];
      $handler->cacheInvalidate($version_cid . '::' . $cid);
    }
  }
}
